{"version":3,"file":"static/js/814.f5fbf061.chunk.js","mappings":"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","sources":["../node_modules/@solana/spl-token/src/instructions/amountToUiAmount.ts","../node_modules/@solana/spl-token/src/actions/amountToUiAmount.ts","../node_modules/@solana/spl-token/src/actions/internal.ts","../node_modules/@solana/spl-token/src/actions/approve.ts","../node_modules/@solana/spl-token/src/instructions/approveChecked.ts","../node_modules/@solana/spl-token/src/actions/approveChecked.ts","../node_modules/@solana/spl-token/src/instructions/burn.ts","../node_modules/@solana/spl-token/src/actions/burn.ts","../node_modules/@solana/spl-token/src/instructions/burnChecked.ts","../node_modules/@solana/spl-token/src/actions/burnChecked.ts","../node_modules/@solana/spl-token/src/instructions/closeAccount.ts","../node_modules/@solana/spl-token/src/actions/closeAccount.ts","../node_modules/@solana/spl-token/src/actions/createAssociatedTokenAccount.ts","../node_modules/@solana/spl-token/src/actions/createAccount.ts","../node_modules/@solana/spl-token/src/actions/createAssociatedTokenAccountIdempotent.ts","../node_modules/@solana/spl-token/src/instructions/initializeMint2.ts","../node_modules/@solana/spl-token/src/actions/createMint.ts","../node_modules/@solana/spl-token/src/instructions/initializeMultisig.ts","../node_modules/@solana/spl-token/src/actions/createMultisig.ts","../node_modules/@solana/spl-token/src/instructions/createNativeMint.ts","../node_modules/@solana/spl-token/src/actions/createNativeMint.ts","../node_modules/@solana/spl-token/src/actions/createWrappedNativeAccount.ts","../node_modules/@solana/spl-token/src/actions/freezeAccount.ts","../node_modules/@solana/spl-token/src/actions/getOrCreateAssociatedTokenAccount.ts","../node_modules/@solana/spl-token/src/actions/mintTo.ts","../node_modules/@solana/spl-token/src/instructions/mintToChecked.ts","../node_modules/@solana/spl-token/src/actions/mintToChecked.ts","../node_modules/@solana/spl-token/src/actions/revoke.ts","../node_modules/@solana/spl-token/src/instructions/setAuthority.ts","../node_modules/@solana/spl-token/src/actions/setAuthority.ts","../node_modules/@solana/spl-token/src/actions/syncNative.ts","../node_modules/@solana/spl-token/src/actions/thawAccount.ts","../node_modules/@solana/spl-token/src/actions/transfer.ts","../node_modules/@solana/spl-token/src/instructions/transferChecked.ts","../node_modules/@solana/spl-token/src/actions/transferChecked.ts","../node_modules/@solana/spl-token/src/instructions/uiAmountToAmount.ts","../node_modules/@solana/spl-token/src/actions/uiAmountToAmount.ts","../node_modules/@solana/spl-token/src/extensions/cpiGuard/instructions.ts","../node_modules/@solana/spl-token/src/extensions/cpiGuard/actions.ts","../node_modules/@solana/spl-token/src/extensions/defaultAccountState/instructions.ts","../node_modules/@solana/spl-token/src/extensions/defaultAccountState/actions.ts","../node_modules/@solana/spl-token/src/extensions/interestBearingMint/instructions.ts","../node_modules/@solana/spl-token/src/extensions/interestBearingMint/actions.ts","../node_modules/@solana/spl-token/src/extensions/memoTransfer/instructions.ts","../node_modules/@solana/spl-token/src/extensions/memoTransfer/actions.ts","../node_modules/@solana/spl-token/src/extensions/transferFee/instructions.ts","../node_modules/@solana/spl-token/src/extensions/transferFee/actions.ts","../node_modules/@solana/spl-token/src/instructions/initializeAccount2.ts","../node_modules/@solana/spl-token/src/instructions/initializeAccount3.ts","../node_modules/@solana/spl-token/src/instructions/decode.ts","../node_modules/@solana/spl-token/src/instructions/initializeImmutableOwner.ts","../node_modules/@solana/spl-token/src/instructions/initializeMintCloseAuthority.ts","../node_modules/@solana/spl-token/src/instructions/reallocate.ts","../node_modules/@solana/spl-token/src/instructions/initializeNonTransferableMint.ts","../node_modules/@solana/spl-token/src/instructions/initializePermanentDelegate.ts"],"sourcesContent":["import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface AmountToUiAmountInstructionData {\n    instruction: TokenInstruction.AmountToUiAmount;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const amountToUiAmountInstructionData = struct<AmountToUiAmountInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n]);\n\n/**\n * Construct a AmountToUiAmount instruction\n *\n * @param mint         Public key of the mint\n * @param amount       Amount of tokens to be converted to UiAmount\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAmountToUiAmountInstruction(\n    mint: PublicKey,\n    amount: number | bigint,\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];\n\n    const data = Buffer.alloc(amountToUiAmountInstructionData.span);\n    amountToUiAmountInstructionData.encode(\n        {\n            instruction: TokenInstruction.AmountToUiAmount,\n            amount: BigInt(amount),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid AmountToUiAmount instruction */\nexport interface DecodedAmountToUiAmountInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.AmountToUiAmount;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a AmountToUiAmount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeAmountToUiAmountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedAmountToUiAmountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== amountToUiAmountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeAmountToUiAmountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.AmountToUiAmount) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated AmountToUiAmount instruction */\nexport interface DecodedAmountToUiAmountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a AmountToUiAmount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeAmountToUiAmountInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedAmountToUiAmountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: amountToUiAmountInstructionData.decode(data),\n    };\n}\n","import type { Connection, PublicKey, Signer, TransactionError } from '@solana/web3.js';\nimport { Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAmountToUiAmountInstruction } from '../instructions/amountToUiAmount.js';\n\n/**\n * Amount as a string using mint-prescribed decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param amount         Amount of tokens to be converted to Ui Amount\n * @param programId      SPL Token program account\n *\n * @return Ui Amount generated\n */\nexport async function amountToUiAmount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    amount: number | bigint,\n    programId = TOKEN_PROGRAM_ID\n): Promise<string | TransactionError | null> {\n    const transaction = new Transaction().add(createAmountToUiAmountInstruction(mint, amount, programId));\n    const { returnData, err } = (await connection.simulateTransaction(transaction, [payer], false)).value;\n    if (returnData?.data) {\n        return Buffer.from(returnData.data[0], returnData.data[1]).toString('utf-8');\n    }\n    return err;\n}\n","import type { Signer } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\n\n/** @internal */\nexport function getSigners(signerOrMultisig: Signer | PublicKey, multiSigners: Signer[]): [PublicKey, Signer[]] {\n    return signerOrMultisig instanceof PublicKey\n        ? [signerOrMultisig, multiSigners]\n        : [signerOrMultisig.publicKey, [signerOrMultisig]];\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createApproveInstruction } from '../instructions/approve.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Approve a delegate to transfer up to a maximum number of tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the token account\n * @param delegate       Account authorized to transfer tokens from the account\n * @param owner          Owner of the account\n * @param amount         Maximum number of tokens the delegate may transfer\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approve(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createApproveInstruction(account, delegate, ownerPublicKey, amount, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface ApproveCheckedInstructionData {\n    instruction: TokenInstruction.ApproveChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const approveCheckedInstructionData = struct<ApproveCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct an ApproveChecked instruction\n *\n * @param account      Account to set the delegate for\n * @param mint         Mint account\n * @param delegate     Account authorized to transfer of tokens from the account\n * @param owner        Owner of the account\n * @param amount       Maximum number of tokens the delegate may transfer\n * @param decimals     Number of decimals in approve amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createApproveCheckedInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: delegate, isSigner: false, isWritable: false },\n        ],\n        owner,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(approveCheckedInstructionData.span);\n    approveCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.ApproveChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid ApproveChecked instruction */\nexport interface DecodedApproveCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        delegate: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.ApproveChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode an ApproveChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeApproveCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedApproveCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== approveCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, delegate, owner, multiSigners },\n        data,\n    } = decodeApproveCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.ApproveChecked) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !delegate || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated ApproveChecked instruction */\nexport interface DecodedApproveCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        delegate: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode an ApproveChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeApproveCheckedInstructionUnchecked({\n    programId,\n    keys: [account, mint, delegate, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedApproveCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data: approveCheckedInstructionData.decode(data),\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createApproveCheckedInstruction } from '../instructions/approveChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Approve a delegate to transfer up to a maximum number of tokens from an account, asserting the token mint and\n * decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the account\n * @param delegate       Account authorized to perform a transfer tokens from the source account\n * @param owner          Owner of the source account\n * @param amount         Maximum number of tokens the delegate may transfer\n * @param decimals       Number of decimals in approve amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approveChecked(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createApproveCheckedInstruction(\n            account,\n            mint,\n            delegate,\n            ownerPublicKey,\n            amount,\n            decimals,\n            multiSigners,\n            programId\n        )\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface BurnInstructionData {\n    instruction: TokenInstruction.Burn;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const burnInstructionData = struct<BurnInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct a Burn instruction\n *\n * @param account      Account to burn tokens from\n * @param mint         Mint for the account\n * @param owner        Owner of the account\n * @param amount       Number of tokens to burn\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createBurnInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(burnInstructionData.span);\n    burnInstructionData.encode(\n        {\n            instruction: TokenInstruction.Burn,\n            amount: BigInt(amount),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Burn instruction */\nexport interface DecodedBurnInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Burn;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Burn instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeBurnInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedBurnInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== burnInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, multiSigners },\n        data,\n    } = decodeBurnInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Burn) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Burn instruction */\nexport interface DecodedBurnInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Burn instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeBurnInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedBurnInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data: burnInstructionData.decode(data),\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createBurnInstruction } from '../instructions/burn.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Burn tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to burn tokens from\n * @param mint           Mint for the account\n * @param owner          Account owner\n * @param amount         Amount to burn\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function burn(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createBurnInstruction(account, mint, ownerPublicKey, amount, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface BurnCheckedInstructionData {\n    instruction: TokenInstruction.BurnChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const burnCheckedInstructionData = struct<BurnCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a BurnChecked instruction\n *\n * @param mint         Mint for the account\n * @param account      Account to burn tokens from\n * @param owner        Owner of the account\n * @param amount       Number of tokens to burn\n * @param decimals     Number of decimals in burn amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createBurnCheckedInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(burnCheckedInstructionData.span);\n    burnCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.BurnChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid BurnChecked instruction */\nexport interface DecodedBurnCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.BurnChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a BurnChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeBurnCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedBurnCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== burnCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, multiSigners },\n        data,\n    } = decodeBurnCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.BurnChecked) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated BurnChecked instruction */\nexport interface DecodedBurnCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a BurnChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeBurnCheckedInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedBurnCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data: burnCheckedInstructionData.decode(data),\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createBurnCheckedInstruction } from '../instructions/burnChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Burn tokens from an account, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to burn tokens from\n * @param mint           Mint for the account\n * @param owner          Account owner\n * @param amount         Amount to burn\n * @param decimals       Number of decimals in amount to burn\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function burnChecked(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createBurnCheckedInstruction(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface CloseAccountInstructionData {\n    instruction: TokenInstruction.CloseAccount;\n}\n\n/** TODO: docs */\nexport const closeAccountInstructionData = struct<CloseAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct a CloseAccount instruction\n *\n * @param account      Account to close\n * @param destination  Account to receive the remaining balance of the closed account\n * @param authority    Account close authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createCloseAccountInstruction(\n    account: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(closeAccountInstructionData.span);\n    closeAccountInstructionData.encode({ instruction: TokenInstruction.CloseAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid CloseAccount instruction */\nexport interface DecodedCloseAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.CloseAccount;\n    };\n}\n\n/**\n * Decode a CloseAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeCloseAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedCloseAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== closeAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, destination, authority, multiSigners },\n        data,\n    } = decodeCloseAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.CloseAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated CloseAccount instruction */\nexport interface DecodedCloseAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a CloseAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeCloseAccountInstructionUnchecked({\n    programId,\n    keys: [account, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedCloseAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: closeAccountInstructionData.decode(data),\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createCloseAccountInstruction } from '../instructions/closeAccount.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Close a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to close\n * @param destination    Account to receive the remaining balance of the closed account\n * @param authority      Authority which is allowed to close the account\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function closeAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createCloseAccountInstruction(account, destination, authorityPublicKey, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddress } from '../state/mint.js';\n\n/**\n * Create and initialize a new associated token account\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint for the account\n * @param owner                    Owner of the new account\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function createAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    const associatedToken = await getAssociatedTokenAddress(mint, owner, false, programId, associatedTokenProgramId);\n\n    const transaction = new Transaction().add(\n        createAssociatedTokenAccountInstruction(\n            payer.publicKey,\n            associatedToken,\n            owner,\n            mint,\n            programId,\n            associatedTokenProgramId\n        )\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n    return associatedToken;\n}\n","import type { ConfirmOptions, Connection, Keypair, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { getAccountLenForMint } from '../extensions/extensionType.js';\nimport { createInitializeAccountInstruction } from '../instructions/initializeAccount.js';\nimport { getMint } from '../state/mint.js';\nimport { createAssociatedTokenAccount } from './createAssociatedTokenAccount.js';\n\n/**\n * Create and initialize a new token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param mint           Mint for the account\n * @param owner          Owner of the new account\n * @param keypair        Optional keypair, defaulting to the associated token account for the `mint` and `owner`\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new token account\n */\nexport async function createAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    keypair?: Keypair,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    // If a keypair isn't provided, create the associated token account and return its address\n    if (!keypair) return await createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId);\n\n    // Otherwise, create the account with the provided keypair and return its public key\n    const mintState = await getMint(connection, mint, confirmOptions?.commitment, programId);\n    const space = getAccountLenForMint(mintState);\n    const lamports = await connection.getMinimumBalanceForRentExemption(space);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space,\n            lamports,\n            programId,\n        }),\n        createInitializeAccountInstruction(keypair.publicKey, mint, owner, programId)\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountIdempotentInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddress } from '../state/mint.js';\n\n/**\n * Create and initialize a new associated token account\n * The instruction will succeed even if the associated token account already exists\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint for the account\n * @param owner                    Owner of the new account\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new or existing associated token account\n */\nexport async function createAssociatedTokenAccountIdempotent(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    const associatedToken = await getAssociatedTokenAddress(mint, owner, false, programId, associatedTokenProgramId);\n\n    const transaction = new Transaction().add(\n        createAssociatedTokenAccountIdempotentInstruction(\n            payer.publicKey,\n            associatedToken,\n            owner,\n            mint,\n            programId,\n            associatedTokenProgramId\n        )\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n    return associatedToken;\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface InitializeMint2InstructionData {\n    instruction: TokenInstruction.InitializeMint2;\n    decimals: number;\n    mintAuthority: PublicKey;\n    freezeAuthorityOption: 1 | 0;\n    freezeAuthority: PublicKey;\n}\n\n/** TODO: docs */\nexport const initializeMint2InstructionData = struct<InitializeMint2InstructionData>([\n    u8('instruction'),\n    u8('decimals'),\n    publicKey('mintAuthority'),\n    u8('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n\n/**\n * Construct an InitializeMint2 instruction\n *\n * @param mint            Token mint account\n * @param decimals        Number of decimals in token account amounts\n * @param mintAuthority   Minting authority\n * @param freezeAuthority Optional authority that can freeze token accounts\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMint2Instruction(\n    mint: PublicKey,\n    decimals: number,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeMint2InstructionData.span);\n    initializeMint2InstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMint2,\n            decimals,\n            mintAuthority,\n            freezeAuthorityOption: freezeAuthority ? 1 : 0,\n            freezeAuthority: freezeAuthority || new PublicKey(0),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeMint2 instruction */\nexport interface DecodedInitializeMint2Instruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMint2;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint2 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMint2Instruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedInitializeMint2Instruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMint2InstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeMint2InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMint2) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMint2 instruction */\nexport interface DecodedInitializeMint2InstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint2 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMint2InstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeMint2InstructionUnchecked {\n    const { instruction, decimals, mintAuthority, freezeAuthorityOption, freezeAuthority } =\n        initializeMint2InstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            decimals,\n            mintAuthority,\n            freezeAuthority: freezeAuthorityOption ? freezeAuthority : null,\n        },\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createInitializeMint2Instruction } from '../instructions/initializeMint2.js';\nimport { getMinimumBalanceForRentExemptMint, MINT_SIZE } from '../state/mint.js';\n\n/**\n * Create and initialize a new mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction and initialization fees\n * @param mintAuthority   Account or multisig that will control minting\n * @param freezeAuthority Optional account or multisig that can freeze token accounts\n * @param decimals        Location of the decimal place\n * @param keypair         Optional keypair, defaulting to a new random one\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Address of the new mint\n */\nexport async function createMint(\n    connection: Connection,\n    payer: Signer,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    decimals: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    const lamports = await getMinimumBalanceForRentExemptMint(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: MINT_SIZE,\n            lamports,\n            programId,\n        }),\n        createInitializeMint2Instruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId)\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, Signer } from '@solana/web3.js';\nimport { PublicKey, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface InitializeMultisigInstructionData {\n    instruction: TokenInstruction.InitializeMultisig;\n    m: number;\n}\n\n/** TODO: docs */\nexport const initializeMultisigInstructionData = struct<InitializeMultisigInstructionData>([\n    u8('instruction'),\n    u8('m'),\n]);\n\n/**\n * Construct an InitializeMultisig instruction\n *\n * @param account   Multisig account\n * @param signers   Full set of signers\n * @param m         Number of required signatures\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMultisigInstruction(\n    account: PublicKey,\n    signers: (Signer | PublicKey)[],\n    m: number,\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    for (const signer of signers) {\n        keys.push({\n            pubkey: signer instanceof PublicKey ? signer : signer.publicKey,\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n\n    const data = Buffer.alloc(initializeMultisigInstructionData.span);\n    initializeMultisigInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMultisig,\n            m,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeMultisig instruction */\nexport interface DecodedInitializeMultisigInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        rent: AccountMeta;\n        signers: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMultisig;\n        m: number;\n    };\n}\n\n/**\n * Decode an InitializeMultisig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMultisigInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedInitializeMultisigInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMultisigInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, rent, signers },\n        data,\n    } = decodeInitializeMultisigInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMultisig) throw new TokenInvalidInstructionTypeError();\n    if (!account || !rent || !signers.length) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            rent,\n            signers,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMultisig instruction */\nexport interface DecodedInitializeMultisigInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n        signers: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        m: number;\n    };\n}\n\n/**\n * Decode an InitializeMultisig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMultisigInstructionUnchecked({\n    programId,\n    keys: [account, rent, ...signers],\n    data,\n}: TransactionInstruction): DecodedInitializeMultisigInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            rent,\n            signers,\n        },\n        data: initializeMultisigInstructionData.decode(data),\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createInitializeMultisigInstruction } from '../instructions/initializeMultisig.js';\nimport { getMinimumBalanceForRentExemptMultisig, MULTISIG_SIZE } from '../state/multisig.js';\n\n/**\n * Create and initialize a new multisig\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param signers        Full set of signers\n * @param m              Number of required signatures\n * @param keypair        Optional keypair, defaulting to a new random one\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new multisig\n */\nexport async function createMultisig(\n    connection: Connection,\n    payer: Signer,\n    signers: PublicKey[],\n    m: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    const lamports = await getMinimumBalanceForRentExemptMultisig(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: MULTISIG_SIZE,\n            lamports,\n            programId,\n        }),\n        createInitializeMultisigInstruction(keypair.publicKey, signers, m, programId)\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey } from '@solana/web3.js';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { NATIVE_MINT_2022, programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface CreateNativeMintInstructionData {\n    instruction: TokenInstruction.CreateNativeMint;\n}\n\n/** TODO: docs */\nexport const createNativeMintInstructionData = struct<CreateNativeMintInstructionData>([u8('instruction')]);\n\n/**\n * Construct a CreateNativeMint instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     Owner of the new account\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createCreateNativeMintInstruction(\n    payer: PublicKey,\n    nativeMintId = NATIVE_MINT_2022,\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: nativeMintId, isSigner: false, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ];\n\n    const data = Buffer.alloc(createNativeMintInstructionData.span);\n    createNativeMintInstructionData.encode({ instruction: TokenInstruction.CreateNativeMint }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import type { ConfirmOptions, Connection, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { NATIVE_MINT_2022, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { createCreateNativeMintInstruction } from '../instructions/createNativeMint.js';\n\n/**\n * Create native mint\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param nativeMint               Native mint id associated with program\n */\nexport async function createNativeMint(\n    connection: Connection,\n    payer: Signer,\n    confirmOptions?: ConfirmOptions,\n    nativeMint = NATIVE_MINT_2022,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<void> {\n    const transaction = new Transaction().add(\n        createCreateNativeMintInstruction(payer.publicKey, nativeMint, programId)\n    );\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, Keypair, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { createInitializeAccountInstruction } from '../instructions/initializeAccount.js';\nimport { createSyncNativeInstruction } from '../instructions/syncNative.js';\nimport { ACCOUNT_SIZE, getMinimumBalanceForRentExemptAccount } from '../state/account.js';\nimport { getAssociatedTokenAddress } from '../state/mint.js';\nimport { createAccount } from './createAccount.js';\n\n/**\n * Create, initialize, and fund a new wrapped native SOL account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param owner          Owner of the new token account\n * @param amount         Number of lamports to wrap\n * @param keypair        Optional keypair, defaulting to the associated token account for the native mint and `owner`\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new wrapped native SOL account\n */\nexport async function createWrappedNativeAccount(\n    connection: Connection,\n    payer: Signer,\n    owner: PublicKey,\n    amount: number,\n    keypair?: Keypair,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    nativeMint = NATIVE_MINT\n): Promise<PublicKey> {\n    // If the amount provided is explicitly 0 or NaN, just create the account without funding it\n    if (!amount) return await createAccount(connection, payer, nativeMint, owner, keypair, confirmOptions, programId);\n\n    // If a keypair isn't provided, create the account at the owner's ATA for the native mint and return its address\n    if (!keypair) {\n        const associatedToken = await getAssociatedTokenAddress(\n            nativeMint,\n            owner,\n            false,\n            programId,\n            ASSOCIATED_TOKEN_PROGRAM_ID\n        );\n\n        const transaction = new Transaction().add(\n            createAssociatedTokenAccountInstruction(\n                payer.publicKey,\n                associatedToken,\n                owner,\n                nativeMint,\n                programId,\n                ASSOCIATED_TOKEN_PROGRAM_ID\n            ),\n            SystemProgram.transfer({\n                fromPubkey: payer.publicKey,\n                toPubkey: associatedToken,\n                lamports: amount,\n            }),\n            createSyncNativeInstruction(associatedToken, programId)\n        );\n\n        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n        return associatedToken;\n    }\n\n    // Otherwise, create the account with the provided keypair and return its public key\n    const lamports = await getMinimumBalanceForRentExemptAccount(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: ACCOUNT_SIZE,\n            lamports,\n            programId,\n        }),\n        SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: keypair.publicKey,\n            lamports: amount,\n        }),\n        createInitializeAccountInstruction(keypair.publicKey, nativeMint, owner, programId)\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createFreezeAccountInstruction } from '../instructions/freezeAccount.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Freeze a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to freeze\n * @param mint           Mint for the account\n * @param authority      Mint freeze authority\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function freezeAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createFreezeAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { Commitment, ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidMintError,\n    TokenInvalidOwnerError,\n} from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport type { Account } from '../state/account.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddress } from '../state/mint.js';\n\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    commitment?: Commitment,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const associatedToken = await getAssociatedTokenAddress(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId\n    );\n\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account: Account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    } catch (error: unknown) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(\n                    createAssociatedTokenAccountInstruction(\n                        payer.publicKey,\n                        associatedToken,\n                        owner,\n                        mint,\n                        programId,\n                        associatedTokenProgramId\n                    )\n                );\n\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            } catch (error: unknown) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        } else {\n            throw error;\n        }\n    }\n\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n\n    return account;\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createMintToInstruction } from '../instructions/mintTo.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Mint tokens to an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param destination    Address of the account to mint to\n * @param authority      Minting authority\n * @param amount         Amount to mint\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintTo(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createMintToInstruction(mint, destination, authorityPublicKey, amount, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface MintToCheckedInstructionData {\n    instruction: TokenInstruction.MintToChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const mintToCheckedInstructionData = struct<MintToCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a MintToChecked instruction\n *\n * @param mint         Public key of the mint\n * @param destination  Address of the token account to mint to\n * @param authority    The mint authority\n * @param amount       Amount to mint\n * @param decimals     Number of decimals in amount to mint\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createMintToCheckedInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(mintToCheckedInstructionData.span);\n    mintToCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.MintToChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid MintToChecked instruction */\nexport interface DecodedMintToCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.MintToChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a MintToChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeMintToCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedMintToCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== mintToCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, multiSigners },\n        data,\n    } = decodeMintToCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.MintToChecked) throw new TokenInvalidInstructionTypeError();\n    if (!mint || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated MintToChecked instruction */\nexport interface DecodedMintToCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a MintToChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeMintToCheckedInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedMintToCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: mintToCheckedInstructionData.decode(data),\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createMintToCheckedInstruction } from '../instructions/mintToChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Mint tokens to an account, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param destination    Address of the account to mint to\n * @param authority      Minting authority\n * @param amount         Amount to mint\n * @param decimals       Number of decimals in amount to mint\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintToChecked(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createMintToCheckedInstruction(mint, destination, authorityPublicKey, amount, decimals, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createRevokeInstruction } from '../instructions/revoke.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Revoke approval for the transfer of tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the token account\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function revoke(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createRevokeInstruction(account, ownerPublicKey, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** Authority types defined by the program */\nexport enum AuthorityType {\n    MintTokens = 0,\n    FreezeAccount = 1,\n    AccountOwner = 2,\n    CloseAccount = 3,\n}\n\n/** TODO: docs */\nexport interface SetAuthorityInstructionData {\n    instruction: TokenInstruction.SetAuthority;\n    authorityType: AuthorityType;\n    newAuthorityOption: 1 | 0;\n    newAuthority: PublicKey;\n}\n\n/** TODO: docs */\nexport const setAuthorityInstructionData = struct<SetAuthorityInstructionData>([\n    u8('instruction'),\n    u8('authorityType'),\n    u8('newAuthorityOption'),\n    publicKey('newAuthority'),\n]);\n\n/**\n * Construct a SetAuthority instruction\n *\n * @param account          Address of the token account\n * @param currentAuthority Current authority of the specified type\n * @param authorityType    Type of authority to set\n * @param newAuthority     New authority of the account\n * @param multiSigners     Signing accounts if `currentAuthority` is a multisig\n * @param programId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSetAuthorityInstruction(\n    account: PublicKey,\n    currentAuthority: PublicKey,\n    authorityType: AuthorityType,\n    newAuthority: PublicKey | null,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);\n\n    const data = Buffer.alloc(setAuthorityInstructionData.span);\n    setAuthorityInstructionData.encode(\n        {\n            instruction: TokenInstruction.SetAuthority,\n            authorityType,\n            newAuthorityOption: newAuthority ? 1 : 0,\n            newAuthority: newAuthority || new PublicKey(0),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid SetAuthority instruction */\nexport interface DecodedSetAuthorityInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        currentAuthority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.SetAuthority;\n        authorityType: AuthorityType;\n        newAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode a SetAuthority instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSetAuthorityInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedSetAuthorityInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== setAuthorityInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, currentAuthority, multiSigners },\n        data,\n    } = decodeSetAuthorityInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.SetAuthority) throw new TokenInvalidInstructionTypeError();\n    if (!account || !currentAuthority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            currentAuthority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated SetAuthority instruction */\nexport interface DecodedSetAuthorityInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        currentAuthority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        authorityType: AuthorityType;\n        newAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode a SetAuthority instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSetAuthorityInstructionUnchecked({\n    programId,\n    keys: [account, currentAuthority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedSetAuthorityInstructionUnchecked {\n    const { instruction, authorityType, newAuthorityOption, newAuthority } = setAuthorityInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            account,\n            currentAuthority,\n            multiSigners,\n        },\n        data: {\n            instruction,\n            authorityType,\n            newAuthority: newAuthorityOption ? newAuthority : null,\n        },\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport type { AuthorityType } from '../instructions/setAuthority.js';\nimport { createSetAuthorityInstruction } from '../instructions/setAuthority.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Assign a new authority to the account\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param account          Address of the account\n * @param currentAuthority Current authority of the specified type\n * @param authorityType    Type of authority to set\n * @param newAuthority     New authority of the account\n * @param multiSigners     Signing accounts if `currentAuthority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function setAuthority(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    currentAuthority: Signer | PublicKey,\n    authorityType: AuthorityType,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [currentAuthorityPublicKey, signers] = getSigners(currentAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createSetAuthorityInstruction(\n            account,\n            currentAuthorityPublicKey,\n            authorityType,\n            newAuthority,\n            multiSigners,\n            programId\n        )\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createSyncNativeInstruction } from '../instructions/syncNative.js';\n\n/**\n * Sync the balance of a native SPL token account to the underlying system account's lamports\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Native account to sync\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function syncNative(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(createSyncNativeInstruction(account, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createThawAccountInstruction } from '../instructions/thawAccount.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Thaw (unfreeze) a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to thaw\n * @param mint           Mint for the account\n * @param authority      Mint freeze authority\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function thawAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createThawAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createTransferInstruction } from '../instructions/transfer.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Transfer tokens from one account to another\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transfer(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferInstruction(source, destination, ownerPublicKey, amount, multiSigners, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface TransferCheckedInstructionData {\n    instruction: TokenInstruction.TransferChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const transferCheckedInstructionData = struct<TransferCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a TransferChecked instruction\n *\n * @param source       Source account\n * @param mint         Mint account\n * @param destination  Destination account\n * @param owner        Owner of the source account\n * @param amount       Number of tokens to transfer\n * @param decimals     Number of decimals in transfer amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedInstruction(\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners\n    );\n\n    const data = Buffer.alloc(transferCheckedInstructionData.span);\n    transferCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid TransferChecked instruction */\nexport interface DecodedTransferCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.TransferChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a TransferChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedTransferCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, mint, destination, owner, multiSigners },\n        data,\n    } = decodeTransferCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferChecked) throw new TokenInvalidInstructionTypeError();\n    if (!source || !mint || !destination || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated TransferChecked instruction */\nexport interface DecodedTransferCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a TransferChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedInstructionUnchecked({\n    programId,\n    keys: [source, mint, destination, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedTransferCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data: transferCheckedInstructionData.decode(data),\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createTransferCheckedInstruction } from '../instructions/transferChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Transfer tokens from one account to another, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferChecked(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferCheckedInstruction(\n            source,\n            mint,\n            destination,\n            ownerPublicKey,\n            amount,\n            decimals,\n            multiSigners,\n            programId\n        )\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { blob, struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface UiAmountToAmountInstructionData {\n    instruction: TokenInstruction.UiAmountToAmount;\n    amount: Uint8Array;\n}\n\n/** TODO: docs */\n\n/**\n * Construct a UiAmountToAmount instruction\n *\n * @param mint         Public key of the mint\n * @param amount       UiAmount of tokens to be converted to Amount\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUiAmountToAmountInstruction(\n    mint: PublicKey,\n    amount: string,\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];\n    const buf = Buffer.from(amount, 'utf8');\n    const uiAmountToAmountInstructionData = struct<UiAmountToAmountInstructionData>([\n        u8('instruction'),\n        blob(buf.length, 'amount'),\n    ]);\n\n    const data = Buffer.alloc(uiAmountToAmountInstructionData.span);\n    uiAmountToAmountInstructionData.encode(\n        {\n            instruction: TokenInstruction.UiAmountToAmount,\n            amount: buf,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid UiAmountToAmount instruction */\nexport interface DecodedUiAmountToAmountInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.UiAmountToAmount;\n        amount: Uint8Array;\n    };\n}\n\n/**\n * Decode a UiAmountToAmount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeUiAmountToAmountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedUiAmountToAmountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    const uiAmountToAmountInstructionData = struct<UiAmountToAmountInstructionData>([\n        u8('instruction'),\n        blob(instruction.data.length - 1, 'amount'),\n    ]);\n    if (instruction.data.length !== uiAmountToAmountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeUiAmountToAmountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.UiAmountToAmount) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated UiAmountToAmount instruction */\nexport interface DecodedUiAmountToAmountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        amount: Uint8Array;\n    };\n}\n\n/**\n * Decode a UiAmountToAmount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeUiAmountToAmountInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedUiAmountToAmountInstructionUnchecked {\n    const uiAmountToAmountInstructionData = struct<UiAmountToAmountInstructionData>([\n        u8('instruction'),\n        blob(data.length - 1, 'amount'),\n    ]);\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: uiAmountToAmountInstructionData.decode(data),\n    };\n}\n","import { u64 } from '@solana/buffer-layout-utils';\nimport type { Connection, PublicKey, Signer, TransactionError } from '@solana/web3.js';\nimport { Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createUiAmountToAmountInstruction } from '../instructions/uiAmountToAmount.js';\n\n/**\n * Amount as a string using mint-prescribed decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param amount         Ui Amount of tokens to be converted to Amount\n * @param programId      SPL Token program account\n *\n * @return Ui Amount generated\n */\nexport async function uiAmountToAmount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    amount: string,\n    programId = TOKEN_PROGRAM_ID\n): Promise<bigint | TransactionError | null> {\n    const transaction = new Transaction().add(createUiAmountToAmountInstruction(mint, amount, programId));\n    const { returnData, err } = (await connection.simulateTransaction(transaction, [payer], false)).value;\n    if (returnData) {\n        const data = Buffer.from(returnData.data[0], returnData.data[1]);\n        return u64().decode(data);\n    }\n    return err;\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum CpiGuardInstruction {\n    Enable = 0,\n    Disable = 1,\n}\n\n/** TODO: docs */\nexport interface CpiGuardInstructionData {\n    instruction: TokenInstruction.CpiGuardExtension;\n    cpiGuardInstruction: CpiGuardInstruction;\n}\n\n/** TODO: docs */\nexport const cpiGuardInstructionData = struct<CpiGuardInstructionData>([u8('instruction'), u8('cpiGuardInstruction')]);\n\n/**\n * Construct an EnableCpiGuard instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createEnableCpiGuardInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    return createCpiGuardInstruction(CpiGuardInstruction.Enable, account, authority, multiSigners, programId);\n}\n\n/**\n * Construct a DisableCpiGuard instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createDisableCpiGuardInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    return createCpiGuardInstruction(CpiGuardInstruction.Disable, account, authority, multiSigners, programId);\n}\n\nfunction createCpiGuardInstruction(\n    cpiGuardInstruction: CpiGuardInstruction,\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[],\n    programId: PublicKey\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(cpiGuardInstructionData.span);\n    cpiGuardInstructionData.encode(\n        {\n            instruction: TokenInstruction.CpiGuardExtension,\n            cpiGuardInstruction,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createDisableCpiGuardInstruction, createEnableCpiGuardInstruction } from './instructions.js';\n\n/**\n * Enable CPI Guard on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function enableCpiGuard(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createEnableCpiGuardInstruction(account, ownerPublicKey, signers, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Disable CPI Guard on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function disableCpiGuard(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createDisableCpiGuardInstruction(account, ownerPublicKey, signers, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport type { AccountState } from '../../state/account.js';\n\nexport enum DefaultAccountStateInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\n/** TODO: docs */\nexport interface DefaultAccountStateInstructionData {\n    instruction: TokenInstruction.DefaultAccountStateExtension;\n    defaultAccountStateInstruction: DefaultAccountStateInstruction;\n    accountState: AccountState;\n}\n\n/** TODO: docs */\nexport const defaultAccountStateInstructionData = struct<DefaultAccountStateInstructionData>([\n    u8('instruction'),\n    u8('defaultAccountStateInstruction'),\n    u8('accountState'),\n]);\n\n/**\n * Construct an InitializeDefaultAccountState instruction\n *\n * @param mint         Mint to initialize\n * @param accountState Default account state to set on all new accounts\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeDefaultAccountStateInstruction(\n    mint: PublicKey,\n    accountState: AccountState,\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(defaultAccountStateInstructionData.span);\n    defaultAccountStateInstructionData.encode(\n        {\n            instruction: TokenInstruction.DefaultAccountStateExtension,\n            defaultAccountStateInstruction: DefaultAccountStateInstruction.Initialize,\n            accountState,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/**\n * Construct an UpdateDefaultAccountState instruction\n *\n * @param mint         Mint to update\n * @param accountState    Default account state to set on all accounts\n * @param freezeAuthority       The mint's freeze authority\n * @param signers         The signer account(s) for a multisig\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateDefaultAccountStateInstruction(\n    mint: PublicKey,\n    accountState: AccountState,\n    freezeAuthority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], freezeAuthority, multiSigners);\n    const data = Buffer.alloc(defaultAccountStateInstructionData.span);\n    defaultAccountStateInstructionData.encode(\n        {\n            instruction: TokenInstruction.DefaultAccountStateExtension,\n            defaultAccountStateInstruction: DefaultAccountStateInstruction.Update,\n            accountState,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport type { AccountState } from '../../state/account.js';\nimport {\n    createInitializeDefaultAccountStateInstruction,\n    createUpdateDefaultAccountStateInstruction,\n} from './instructions.js';\n\n/**\n * Initialize a default account state on a mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint        Mint to initialize with extension\n * @param state        Account state with which to initialize new accounts\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function initializeDefaultAccountState(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    state: AccountState,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(createInitializeDefaultAccountStateInstruction(mint, state, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n\n/**\n * Update the default account state on a mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint        Mint to modify\n * @param state        New account state to set on created accounts\n * @param freezeAuthority          Freeze authority of the mint\n * @param multiSigners   Signing accounts if `freezeAuthority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateDefaultAccountState(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    state: AccountState,\n    freezeAuthority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [freezeAuthorityPublicKey, signers] = getSigners(freezeAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateDefaultAccountStateInstruction(mint, state, freezeAuthorityPublicKey, signers, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { s16, struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum InterestBearingMintInstruction {\n    Initialize = 0,\n    UpdateRate = 1,\n}\n\nexport interface InterestBearingMintInitializeInstructionData {\n    instruction: TokenInstruction.InterestBearingMintExtension;\n    interestBearingMintInstruction: InterestBearingMintInstruction.Initialize;\n    rateAuthority: PublicKey;\n    rate: number;\n}\n\nexport interface InterestBearingMintUpdateRateInstructionData {\n    instruction: TokenInstruction.InterestBearingMintExtension;\n    interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate;\n    rate: number;\n}\n\nexport const interestBearingMintInitializeInstructionData = struct<InterestBearingMintInitializeInstructionData>([\n    u8('instruction'),\n    u8('interestBearingMintInstruction'),\n    // TODO: Make this an optional public key\n    publicKey('rateAuthority'),\n    s16('rate'),\n]);\n\nexport const interestBearingMintUpdateRateInstructionData = struct<InterestBearingMintUpdateRateInstructionData>([\n    u8('instruction'),\n    u8('interestBearingMintInstruction'),\n    s16('rate'),\n]);\n\n/**\n * Construct an InitializeInterestBearingMint instruction\n *\n * @param mint           Mint to initialize\n * @param rateAuthority  The public key for the account that can update the rate\n * @param rate           The initial interest rate\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeInterestBearingMintInstruction(\n    mint: PublicKey,\n    rateAuthority: PublicKey,\n    rate: number,\n    programId = TOKEN_2022_PROGRAM_ID\n) {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(interestBearingMintInitializeInstructionData.span);\n    interestBearingMintInitializeInstructionData.encode(\n        {\n            instruction: TokenInstruction.InterestBearingMintExtension,\n            interestBearingMintInstruction: InterestBearingMintInstruction.Initialize,\n            rateAuthority,\n            rate,\n        },\n        data\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/**\n * Construct an UpdateRateInterestBearingMint instruction\n *\n * @param mint           Mint to initialize\n * @param rateAuthority  The public key for the account that can update the rate\n * @param rate           The updated interest rate\n * @param multiSigners   Signing accounts if `rateAuthority` is a multisig\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateRateInterestBearingMintInstruction(\n    mint: PublicKey,\n    rateAuthority: PublicKey,\n    rate: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n) {\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: rateAuthority, isSigner: !multiSigners.length, isWritable: false },\n        ],\n        rateAuthority,\n        multiSigners\n    );\n    const data = Buffer.alloc(interestBearingMintUpdateRateInstructionData.span);\n    interestBearingMintUpdateRateInstructionData.encode(\n        {\n            instruction: TokenInstruction.InterestBearingMintExtension,\n            interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate,\n            rate,\n        },\n        data\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createInitializeMintInstruction } from '../../instructions/initializeMint.js';\nimport { ExtensionType, getMintLen } from '../extensionType.js';\nimport {\n    createInitializeInterestBearingMintInstruction,\n    createUpdateRateInterestBearingMintInstruction,\n} from './instructions.js';\n\n/**\n * Initialize an interest bearing account on a mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mintAuthority   Account or multisig that will control minting\n * @param freezeAuthority Optional account or multisig that can freeze token accounts\n * @param rateAuthority   The public key for the account that can update the rate\n * @param rate            The initial interest rate\n * @param decimals        Location of the decimal place\n * @param keypair         Optional keypair, defaulting to a new random one\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Public key of the mint\n */\nexport async function createInterestBearingMint(\n    connection: Connection,\n    payer: Signer,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey,\n    rateAuthority: PublicKey,\n    rate: number,\n    decimals: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<PublicKey> {\n    const mintLen = getMintLen([ExtensionType.InterestBearingConfig]);\n    const lamports = await connection.getMinimumBalanceForRentExemption(mintLen);\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: mintLen,\n            lamports,\n            programId,\n        }),\n        createInitializeInterestBearingMintInstruction(keypair.publicKey, rateAuthority, rate, programId),\n        createInitializeMintInstruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId)\n    );\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n    return keypair.publicKey;\n}\n\n/**\n * Update the interest rate of an interest bearing account\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mint            Public key of the mint\n * @param rateAuthority   The public key for the account that can update the rate\n * @param rate            The initial interest rate\n * @param multiSigners    Signing accounts if `owner` is a multisig\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateRateInterestBearingMint(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    rateAuthority: Signer,\n    rate: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<string> {\n    const [rateAuthorityPublicKey, signers] = getSigners(rateAuthority, multiSigners);\n    const transaction = new Transaction().add(\n        createUpdateRateInterestBearingMintInstruction(mint, rateAuthorityPublicKey, rate, signers, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, rateAuthority, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum MemoTransferInstruction {\n    Enable = 0,\n    Disable = 1,\n}\n\n/** TODO: docs */\nexport interface MemoTransferInstructionData {\n    instruction: TokenInstruction.MemoTransferExtension;\n    memoTransferInstruction: MemoTransferInstruction;\n}\n\n/** TODO: docs */\nexport const memoTransferInstructionData = struct<MemoTransferInstructionData>([\n    u8('instruction'),\n    u8('memoTransferInstruction'),\n]);\n\n/**\n * Construct an EnableRequiredMemoTransfers instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createEnableRequiredMemoTransfersInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    return createMemoTransferInstruction(MemoTransferInstruction.Enable, account, authority, multiSigners, programId);\n}\n\n/**\n * Construct a DisableMemoTransfer instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createDisableRequiredMemoTransfersInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    return createMemoTransferInstruction(MemoTransferInstruction.Disable, account, authority, multiSigners, programId);\n}\n\nfunction createMemoTransferInstruction(\n    memoTransferInstruction: MemoTransferInstruction,\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[],\n    programId: PublicKey\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(memoTransferInstructionData.span);\n    memoTransferInstructionData.encode(\n        {\n            instruction: TokenInstruction.MemoTransferExtension,\n            memoTransferInstruction,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    createDisableRequiredMemoTransfersInstruction,\n    createEnableRequiredMemoTransfersInstruction,\n} from './instructions.js';\n\n/**\n * Enable memo transfers on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function enableRequiredMemoTransfers(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createEnableRequiredMemoTransfersInstruction(account, ownerPublicKey, signers, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Disable memo transfers on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function disableRequiredMemoTransfers(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createDisableRequiredMemoTransfersInstruction(account, ownerPublicKey, signers, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u16, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum TransferFeeInstruction {\n    InitializeTransferFeeConfig = 0,\n    TransferCheckedWithFee = 1,\n    WithdrawWithheldTokensFromMint = 2,\n    WithdrawWithheldTokensFromAccounts = 3,\n    HarvestWithheldTokensToMint = 4,\n    SetTransferFee = 5,\n}\n\n// InitializeTransferFeeConfig\n\n/** TODO: docs */\nexport interface InitializeTransferFeeConfigInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n    transferFeeConfigAuthorityOption: 1 | 0;\n    transferFeeConfigAuthority: PublicKey;\n    withdrawWithheldAuthorityOption: 1 | 0;\n    withdrawWithheldAuthority: PublicKey;\n    transferFeeBasisPoints: number;\n    maximumFee: bigint;\n}\n\n/** TODO: docs */\nexport const initializeTransferFeeConfigInstructionData = struct<InitializeTransferFeeConfigInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u8('transferFeeConfigAuthorityOption'),\n    publicKey('transferFeeConfigAuthority'),\n    u8('withdrawWithheldAuthorityOption'),\n    publicKey('withdrawWithheldAuthority'),\n    u16('transferFeeBasisPoints'),\n    u64('maximumFee'),\n]);\n\n/**\n * Construct an InitializeTransferFeeConfig instruction\n *\n * @param mint            Token mint account\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee        Maximum fee assessed on transfers\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferFeeConfigInstruction(\n    mint: PublicKey,\n    transferFeeConfigAuthority: PublicKey | null,\n    withdrawWithheldAuthority: PublicKey | null,\n    transferFeeBasisPoints: number,\n    maximumFee: bigint,\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeTransferFeeConfigInstructionData.span);\n    initializeTransferFeeConfigInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n            transferFeeConfigAuthorityOption: transferFeeConfigAuthority ? 1 : 0,\n            transferFeeConfigAuthority: transferFeeConfigAuthority || new PublicKey(0),\n            withdrawWithheldAuthorityOption: withdrawWithheldAuthority ? 1 : 0,\n            withdrawWithheldAuthority: withdrawWithheldAuthority || new PublicKey(0),\n            transferFeeBasisPoints: transferFeeBasisPoints,\n            maximumFee: maximumFee,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeTransferFeeConfig instruction */\nexport interface DecodedInitializeTransferFeeConfigInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n        transferFeeConfigAuthority: PublicKey | null;\n        withdrawWithheldAuthority: PublicKey | null;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an InitializeTransferFeeConfig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeTransferFeeConfigInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedInitializeTransferFeeConfigInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeTransferFeeConfigInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeTransferFeeConfig instruction */\nexport interface DecodedInitializeTransferFeeConfigInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n        transferFeeConfigAuthority: PublicKey | null;\n        withdrawWithheldAuthority: PublicKey | null;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an InitializeTransferFeeConfig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeTransferFeeConfigInstructionUnchecked {\n    const {\n        instruction,\n        transferFeeInstruction,\n        transferFeeConfigAuthorityOption,\n        transferFeeConfigAuthority,\n        withdrawWithheldAuthorityOption,\n        withdrawWithheldAuthority,\n        transferFeeBasisPoints,\n        maximumFee,\n    } = initializeTransferFeeConfigInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            transferFeeConfigAuthority: transferFeeConfigAuthorityOption ? transferFeeConfigAuthority : null,\n            withdrawWithheldAuthority: withdrawWithheldAuthorityOption ? withdrawWithheldAuthority : null,\n            transferFeeBasisPoints,\n            maximumFee,\n        },\n    };\n}\n\n// TransferCheckedWithFee\nexport interface TransferCheckedWithFeeInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n    amount: bigint;\n    decimals: number;\n    fee: bigint;\n}\n\nexport const transferCheckedWithFeeInstructionData = struct<TransferCheckedWithFeeInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u64('amount'),\n    u8('decimals'),\n    u64('fee'),\n]);\n\n/**\n * Construct an TransferCheckedWithFee instruction\n *\n * @param source          The source account\n * @param mint            The token mint\n * @param destination     The destination account\n * @param authority       The source account's owner/delegate\n * @param signers         The signer account(s)\n * @param amount          The amount of tokens to transfer\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedWithFeeInstruction(\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\n    transferCheckedWithFeeInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n            amount,\n            decimals,\n            fee,\n        },\n        data\n    );\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid TransferCheckedWithFee instruction */\nexport interface DecodedTransferCheckedWithFeeInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n        amount: bigint;\n        decimals: number;\n        fee: bigint;\n    };\n}\n\n/**\n * Decode a TransferCheckedWithFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedWithFeeInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedTransferCheckedWithFeeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedWithFeeInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, mint, destination, authority, signers },\n        data,\n    } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated TransferCheckedWithFees instruction */\nexport interface DecodedTransferCheckedWithFeeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n        amount: bigint;\n        decimals: number;\n        fee: bigint;\n    };\n}\n\n/**\n * Decode a TransferCheckedWithFees instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedWithFeeInstructionUnchecked({\n    programId,\n    keys: [source, mint, destination, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedTransferCheckedWithFeeInstructionUnchecked {\n    const { instruction, transferFeeInstruction, amount, decimals, fee } =\n        transferCheckedWithFeeInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            amount,\n            decimals,\n            fee,\n        },\n    };\n}\n\n// WithdrawWithheldTokensFromMint\nexport interface WithdrawWithheldTokensFromMintInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n}\n\nexport const withdrawWithheldTokensFromMintInstructionData = struct<WithdrawWithheldTokensFromMintInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n\n/**\n * Construct a WithdrawWithheldTokensFromMint instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromMintInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    signers: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\n    withdrawWithheldTokensFromMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint,\n        },\n        data\n    );\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        signers\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\nexport interface DecodedWithdrawWithheldTokensFromMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedWithdrawWithheldTokensFromMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, signers },\n        data,\n    } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\nexport interface DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\n    const { instruction, transferFeeInstruction } = withdrawWithheldTokensFromMintInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n\n// WithdrawWithheldTokensFromAccounts\nexport interface WithdrawWithheldTokensFromAccountsInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n    numTokenAccounts: number;\n}\n\nexport const withdrawWithheldTokensFromAccountsInstructionData =\n    struct<WithdrawWithheldTokensFromAccountsInstructionData>([\n        u8('instruction'),\n        u8('transferFeeInstruction'),\n        u8('numTokenAccounts'),\n    ]);\n\n/**\n * Construct a WithdrawWithheldTokensFromAccounts instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromAccountsInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    signers: (Signer | PublicKey)[],\n    sources: PublicKey[],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\n    withdrawWithheldTokensFromAccountsInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n            numTokenAccounts: sources.length,\n        },\n        data\n    );\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        signers\n    );\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n        numTokenAccounts: number;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedWithdrawWithheldTokensFromAccountsInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, signers, sources },\n        data,\n    } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n            sources: sources ? sources : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n        numTokenAccounts: number;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({\n    programId,\n    keys,\n    data,\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\n    const { instruction, transferFeeInstruction, numTokenAccounts } =\n        withdrawWithheldTokensFromAccountsInstructionData.decode(data);\n    const [mint, destination, authority, signers, sources] = [\n        keys[0],\n        keys[1],\n        keys[2],\n        keys.slice(3, 3 + numTokenAccounts),\n        keys.slice(-1 * numTokenAccounts),\n    ];\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            numTokenAccounts,\n        },\n    };\n}\n\n// HarvestWithheldTokensToMint\n\nexport interface HarvestWithheldTokensToMintInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n}\n\nexport const harvestWithheldTokensToMintInstructionData = struct<HarvestWithheldTokensToMintInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n\n/**\n * Construct a HarvestWithheldTokensToMint instruction\n *\n * @param mint              The token mint\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createHarvestWithheldTokensToMintInstruction(\n    mint: PublicKey,\n    sources: PublicKey[],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\n    harvestWithheldTokensToMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint,\n        },\n        data\n    );\n    const keys: AccountMeta[] = [];\n    keys.push({ pubkey: mint, isSigner: false, isWritable: true });\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\nexport interface DecodedHarvestWithheldTokensToMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n    };\n}\n\n/**\n * Decode a HarvestWithheldTokensToMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedHarvestWithheldTokensToMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, sources },\n        data,\n    } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\nexport interface DecodedHarvestWithheldTokensToMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n    };\n}\n\n/**\n * Decode a HarvestWithheldTokensToMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked({\n    programId,\n    keys: [mint, ...sources],\n    data,\n}: TransactionInstruction): DecodedHarvestWithheldTokensToMintInstructionUnchecked {\n    const { instruction, transferFeeInstruction } = harvestWithheldTokensToMintInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    createHarvestWithheldTokensToMintInstruction,\n    createTransferCheckedWithFeeInstruction,\n    createWithdrawWithheldTokensFromAccountsInstruction,\n    createWithdrawWithheldTokensFromMintInstruction,\n} from './instructions.js';\n\n/**\n * Transfer tokens from one account to another, asserting the transfer fee, token mint, and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferCheckedWithFee(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferCheckedWithFeeInstruction(\n            source,\n            mint,\n            destination,\n            ownerPublicKey,\n            amount,\n            decimals,\n            fee,\n            multiSigners,\n            programId\n        )\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Withdraw withheld tokens from mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param destination    The destination account\n * @param authority      The mint's withdraw withheld tokens authority\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function withdrawWithheldTokensFromMint(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createWithdrawWithheldTokensFromMintInstruction(mint, destination, authorityPublicKey, signers, programId)\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Withdraw withheld tokens from accounts\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param destination    The destination account\n * @param authority      The mint's withdraw withheld tokens authority\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param sources        Source accounts from which to withdraw withheld fees\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function withdrawWithheldTokensFromAccounts(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[],\n    sources: PublicKey[],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createWithdrawWithheldTokensFromAccountsInstruction(\n            mint,\n            destination,\n            authorityPublicKey,\n            signers,\n            sources,\n            programId\n        )\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Harvest withheld tokens from accounts to the mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param sources        Source accounts from which to withdraw withheld fees\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function harvestWithheldTokensToMint(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    sources: PublicKey[],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(createHarvestWithheldTokensToMintInstruction(mint, sources, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\nexport interface InitializeAccount2InstructionData {\n    instruction: TokenInstruction.InitializeAccount2;\n    owner: PublicKey;\n}\n\nexport const initializeAccount2InstructionData = struct<InitializeAccount2InstructionData>([\n    u8('instruction'),\n    publicKey('owner'),\n]);\n\n/**\n * Construct an InitializeAccount2 instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     New account's owner/multisignature\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccount2Instruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(initializeAccount2InstructionData.span);\n    initializeAccount2InstructionData.encode({ instruction: TokenInstruction.InitializeAccount2, owner }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeAccount2 instruction */\nexport interface DecodedInitializeAccount2Instruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        rent: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeAccount2;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount2 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccount2Instruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedInitializeAccount2Instruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccount2InstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, rent },\n        data,\n    } = decodeInitializeAccount2InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount2) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !rent) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            rent,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeAccount2 instruction */\nexport interface DecodedInitializeAccount2InstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount2 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccount2InstructionUnchecked({\n    programId,\n    keys: [account, mint, rent],\n    data,\n}: TransactionInstruction): DecodedInitializeAccount2InstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            rent,\n        },\n        data: initializeAccount2InstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\nexport interface InitializeAccount3InstructionData {\n    instruction: TokenInstruction.InitializeAccount3;\n    owner: PublicKey;\n}\n\nexport const initializeAccount3InstructionData = struct<InitializeAccount3InstructionData>([\n    u8('instruction'),\n    publicKey('owner'),\n]);\n\n/**\n * Construct an InitializeAccount3 instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     New account's owner/multisignature\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccount3Instruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(initializeAccount3InstructionData.span);\n    initializeAccount3InstructionData.encode({ instruction: TokenInstruction.InitializeAccount3, owner }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeAccount3 instruction */\nexport interface DecodedInitializeAccount3Instruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeAccount3;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount3 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccount3Instruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedInitializeAccount3Instruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccount3InstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint },\n        data,\n    } = decodeInitializeAccount3InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount3) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeAccount3 instruction */\nexport interface DecodedInitializeAccount3InstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount3 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccount3InstructionUnchecked({\n    programId,\n    keys: [account, mint],\n    data,\n}: TransactionInstruction): DecodedInitializeAccount3InstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n        },\n        data: initializeAccount3InstructionData.decode(data),\n    };\n}\n","import { u8 } from '@solana/buffer-layout';\nimport type { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionTypeError } from '../errors.js';\nimport type { DecodedAmountToUiAmountInstruction } from './amountToUiAmount.js';\nimport { decodeAmountToUiAmountInstruction } from './amountToUiAmount.js';\nimport type { DecodedApproveInstruction } from './approve.js';\nimport { decodeApproveInstruction } from './approve.js';\nimport type { DecodedApproveCheckedInstruction } from './approveChecked.js';\nimport { decodeApproveCheckedInstruction } from './approveChecked.js';\nimport type { DecodedBurnInstruction } from './burn.js';\nimport { decodeBurnInstruction } from './burn.js';\nimport type { DecodedBurnCheckedInstruction } from './burnChecked.js';\nimport { decodeBurnCheckedInstruction } from './burnChecked.js';\nimport type { DecodedCloseAccountInstruction } from './closeAccount.js';\nimport { decodeCloseAccountInstruction } from './closeAccount.js';\nimport type { DecodedFreezeAccountInstruction } from './freezeAccount.js';\nimport { decodeFreezeAccountInstruction } from './freezeAccount.js';\nimport type { DecodedInitializeAccountInstruction } from './initializeAccount.js';\nimport { decodeInitializeAccountInstruction } from './initializeAccount.js';\nimport type { DecodedInitializeAccount2Instruction } from './initializeAccount2.js';\nimport { decodeInitializeAccount2Instruction } from './initializeAccount2.js';\nimport type { DecodedInitializeAccount3Instruction } from './initializeAccount3.js';\nimport { decodeInitializeAccount3Instruction } from './initializeAccount3.js';\nimport type { DecodedInitializeMintInstruction } from './initializeMint.js';\nimport { decodeInitializeMintInstruction } from './initializeMint.js';\nimport type { DecodedInitializeMint2Instruction } from './initializeMint2.js';\nimport { decodeInitializeMint2Instruction } from './initializeMint2.js';\nimport type { DecodedInitializeMultisigInstruction } from './initializeMultisig.js';\nimport { decodeInitializeMultisigInstruction } from './initializeMultisig.js';\nimport type { DecodedMintToInstruction } from './mintTo.js';\nimport { decodeMintToInstruction } from './mintTo.js';\nimport type { DecodedMintToCheckedInstruction } from './mintToChecked.js';\nimport { decodeMintToCheckedInstruction } from './mintToChecked.js';\nimport type { DecodedRevokeInstruction } from './revoke.js';\nimport { decodeRevokeInstruction } from './revoke.js';\nimport type { DecodedSetAuthorityInstruction } from './setAuthority.js';\nimport { decodeSetAuthorityInstruction } from './setAuthority.js';\nimport type { DecodedSyncNativeInstruction } from './syncNative.js';\nimport { decodeSyncNativeInstruction } from './syncNative.js';\nimport type { DecodedThawAccountInstruction } from './thawAccount.js';\nimport { decodeThawAccountInstruction } from './thawAccount.js';\nimport type { DecodedTransferInstruction } from './transfer.js';\nimport { decodeTransferInstruction } from './transfer.js';\nimport type { DecodedTransferCheckedInstruction } from './transferChecked.js';\nimport { decodeTransferCheckedInstruction } from './transferChecked.js';\nimport { TokenInstruction } from './types.js';\nimport type { DecodedUiAmountToAmountInstruction } from './uiAmountToAmount.js';\nimport { decodeUiAmountToAmountInstruction } from './uiAmountToAmount.js';\n\n/** TODO: docs */\nexport type DecodedInstruction =\n    | DecodedInitializeMintInstruction\n    | DecodedInitializeAccountInstruction\n    | DecodedInitializeMultisigInstruction\n    | DecodedTransferInstruction\n    | DecodedApproveInstruction\n    | DecodedRevokeInstruction\n    | DecodedSetAuthorityInstruction\n    | DecodedMintToInstruction\n    | DecodedBurnInstruction\n    | DecodedCloseAccountInstruction\n    | DecodedFreezeAccountInstruction\n    | DecodedThawAccountInstruction\n    | DecodedTransferCheckedInstruction\n    | DecodedApproveCheckedInstruction\n    | DecodedMintToCheckedInstruction\n    | DecodedBurnCheckedInstruction\n    | DecodedInitializeAccount2Instruction\n    | DecodedSyncNativeInstruction\n    | DecodedInitializeAccount3Instruction\n    | DecodedInitializeMint2Instruction\n    | DecodedAmountToUiAmountInstruction\n    | DecodedUiAmountToAmountInstruction\n    // | DecodedInitializeMultisig2Instruction\n    // TODO: implement ^ and remove `never`\n    | never;\n\n/** TODO: docs */\nexport function decodeInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID\n): DecodedInstruction {\n    if (!instruction.data.length) throw new TokenInvalidInstructionDataError();\n\n    const type = u8().decode(instruction.data);\n    if (type === TokenInstruction.InitializeMint) return decodeInitializeMintInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount) return decodeInitializeAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeMultisig)\n        return decodeInitializeMultisigInstruction(instruction, programId);\n    if (type === TokenInstruction.Transfer) return decodeTransferInstruction(instruction, programId);\n    if (type === TokenInstruction.Approve) return decodeApproveInstruction(instruction, programId);\n    if (type === TokenInstruction.Revoke) return decodeRevokeInstruction(instruction, programId);\n    if (type === TokenInstruction.SetAuthority) return decodeSetAuthorityInstruction(instruction, programId);\n    if (type === TokenInstruction.MintTo) return decodeMintToInstruction(instruction, programId);\n    if (type === TokenInstruction.Burn) return decodeBurnInstruction(instruction, programId);\n    if (type === TokenInstruction.CloseAccount) return decodeCloseAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.FreezeAccount) return decodeFreezeAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.ThawAccount) return decodeThawAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.TransferChecked) return decodeTransferCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.ApproveChecked) return decodeApproveCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.MintToChecked) return decodeMintToCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.BurnChecked) return decodeBurnCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount2)\n        return decodeInitializeAccount2Instruction(instruction, programId);\n    if (type === TokenInstruction.SyncNative) return decodeSyncNativeInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount3)\n        return decodeInitializeAccount3Instruction(instruction, programId);\n    if (type === TokenInstruction.InitializeMint2) return decodeInitializeMint2Instruction(instruction, programId);\n    if (type === TokenInstruction.AmountToUiAmount) return decodeAmountToUiAmountInstruction(instruction, programId);\n    if (type === TokenInstruction.UiAmountToAmount) return decodeUiAmountToAmountInstruction(instruction, programId);\n    // TODO: implement\n    if (type === TokenInstruction.InitializeMultisig2) throw new TokenInvalidInstructionTypeError();\n\n    throw new TokenInvalidInstructionTypeError();\n}\n\n/** TODO: docs */\nexport function isInitializeMintInstruction(decoded: DecodedInstruction): decoded is DecodedInitializeMintInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMint;\n}\n\n/** TODO: docs */\nexport function isInitializeAccountInstruction(\n    decoded: DecodedInstruction\n): decoded is DecodedInitializeAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount;\n}\n\n/** TODO: docs */\nexport function isInitializeMultisigInstruction(\n    decoded: DecodedInstruction\n): decoded is DecodedInitializeMultisigInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMultisig;\n}\n\n/** TODO: docs */\nexport function isTransferInstruction(decoded: DecodedInstruction): decoded is DecodedTransferInstruction {\n    return decoded.data.instruction === TokenInstruction.Transfer;\n}\n\n/** TODO: docs */\nexport function isApproveInstruction(decoded: DecodedInstruction): decoded is DecodedApproveInstruction {\n    return decoded.data.instruction === TokenInstruction.Approve;\n}\n\n/** TODO: docs */\nexport function isRevokeInstruction(decoded: DecodedInstruction): decoded is DecodedRevokeInstruction {\n    return decoded.data.instruction === TokenInstruction.Revoke;\n}\n\n/** TODO: docs */\nexport function isSetAuthorityInstruction(decoded: DecodedInstruction): decoded is DecodedSetAuthorityInstruction {\n    return decoded.data.instruction === TokenInstruction.SetAuthority;\n}\n\n/** TODO: docs */\nexport function isMintToInstruction(decoded: DecodedInstruction): decoded is DecodedMintToInstruction {\n    return decoded.data.instruction === TokenInstruction.MintTo;\n}\n\n/** TODO: docs */\nexport function isBurnInstruction(decoded: DecodedInstruction): decoded is DecodedBurnInstruction {\n    return decoded.data.instruction === TokenInstruction.Burn;\n}\n\n/** TODO: docs */\nexport function isCloseAccountInstruction(decoded: DecodedInstruction): decoded is DecodedCloseAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.CloseAccount;\n}\n\n/** TODO: docs */\nexport function isFreezeAccountInstruction(decoded: DecodedInstruction): decoded is DecodedFreezeAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.FreezeAccount;\n}\n\n/** TODO: docs */\nexport function isThawAccountInstruction(decoded: DecodedInstruction): decoded is DecodedThawAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.ThawAccount;\n}\n\n/** TODO: docs */\nexport function isTransferCheckedInstruction(\n    decoded: DecodedInstruction\n): decoded is DecodedTransferCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.TransferChecked;\n}\n\n/** TODO: docs */\nexport function isApproveCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedApproveCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.ApproveChecked;\n}\n\n/** TODO: docs */\nexport function isMintToCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedMintToCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.MintToChecked;\n}\n\n/** TODO: docs */\nexport function isBurnCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedBurnCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.BurnChecked;\n}\n\n/** TODO: docs */\nexport function isInitializeAccount2Instruction(\n    decoded: DecodedInstruction\n): decoded is DecodedInitializeAccount2Instruction {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount2;\n}\n\n/** TODO: docs */\nexport function isSyncNativeInstruction(decoded: DecodedInstruction): decoded is DecodedSyncNativeInstruction {\n    return decoded.data.instruction === TokenInstruction.SyncNative;\n}\n\n/** TODO: docs */\nexport function isInitializeAccount3Instruction(\n    decoded: DecodedInstruction\n): decoded is DecodedInitializeAccount3Instruction {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount3;\n}\n\n/** TODO: docs, implement */\n// export function isInitializeMultisig2Instruction(\n//     decoded: DecodedInstruction\n// ): decoded is DecodedInitializeMultisig2Instruction {\n//     return decoded.data.instruction === TokenInstruction.InitializeMultisig2;\n// }\n\n/** TODO: docs */\nexport function isInitializeMint2Instruction(\n    decoded: DecodedInstruction\n): decoded is DecodedInitializeMint2Instruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMint2;\n}\n\n/** TODO: docs */\nexport function isAmountToUiAmountInstruction(\n    decoded: DecodedInstruction\n): decoded is DecodedAmountToUiAmountInstruction {\n    return decoded.data.instruction === TokenInstruction.AmountToUiAmount;\n}\n\n/** TODO: docs */\nexport function isUiamountToAmountInstruction(\n    decoded: DecodedInstruction\n): decoded is DecodedUiAmountToAmountInstruction {\n    return decoded.data.instruction === TokenInstruction.UiAmountToAmount;\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** Deserialized instruction for the initiation of an immutable owner account */\nexport interface InitializeImmutableOwnerInstructionData {\n    instruction: TokenInstruction.InitializeImmutableOwner;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeImmutableOwnerInstructionData = struct<InitializeImmutableOwnerInstructionData>([\n    u8('instruction'),\n]);\n\n/**\n * Construct an InitializeImmutableOwner instruction\n *\n * @param account           Immutable Owner Account\n * @param programId         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeImmutableOwnerInstruction(\n    account: PublicKey,\n    programId: PublicKey\n): TransactionInstruction {\n    const keys = [{ pubkey: account, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeImmutableOwnerInstructionData.span);\n    initializeImmutableOwnerInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeImmutableOwner,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeImmutableOwner instruction */\nexport interface DecodedInitializeImmutableOwnerInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeImmutableOwner;\n    };\n}\n\n/**\n * Decode an InitializeImmutableOwner instruction and validate it\n *\n * @param instruction InitializeImmutableOwner instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeImmutableOwnerInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedInitializeImmutableOwnerInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeImmutableOwnerInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account },\n        data,\n    } = decodeInitializeImmutableOwnerInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeImmutableOwner) throw new TokenInvalidInstructionTypeError();\n    if (!account) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeImmutableOwner instruction */\nexport interface DecodedInitializeImmutableOwnerInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode an InitializeImmutableOwner instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeImmutableOwnerInstructionUnchecked({\n    programId,\n    keys: [account],\n    data,\n}: TransactionInstruction): DecodedInitializeImmutableOwnerInstructionUnchecked {\n    const { instruction } = initializeImmutableOwnerInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            account: account,\n        },\n        data: {\n            instruction,\n        },\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface InitializeMintCloseAuthorityInstructionData {\n    instruction: TokenInstruction.InitializeMintCloseAuthority;\n    closeAuthorityOption: 1 | 0;\n    closeAuthority: PublicKey;\n}\n\n/** TODO: docs */\nexport const initializeMintCloseAuthorityInstructionData = struct<InitializeMintCloseAuthorityInstructionData>([\n    u8('instruction'),\n    u8('closeAuthorityOption'),\n    publicKey('closeAuthority'),\n]);\n\n/**\n * Construct an InitializeMintCloseAuthority instruction\n *\n * @param mint            Token mint account\n * @param closeAuthority  Optional authority that can close the mint\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMintCloseAuthorityInstruction(\n    mint: PublicKey,\n    closeAuthority: PublicKey | null,\n    programId: PublicKey\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeMintCloseAuthorityInstructionData.span);\n    initializeMintCloseAuthorityInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMintCloseAuthority,\n            closeAuthorityOption: closeAuthority ? 1 : 0,\n            closeAuthority: closeAuthority || new PublicKey(0),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeMintCloseAuthority instruction */\nexport interface DecodedInitializeMintCloseAuthorityInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMintCloseAuthority;\n        closeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMintCloseAuthority instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMintCloseAuthorityInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedInitializeMintCloseAuthorityInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMintCloseAuthorityInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeMintCloseAuthorityInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMintCloseAuthority)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMintCloseAuthority instruction */\nexport interface DecodedInitializeMintCloseAuthorityInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        closeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMintCloseAuthority instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMintCloseAuthorityInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeMintCloseAuthorityInstructionUnchecked {\n    const { instruction, closeAuthorityOption, closeAuthority } =\n        initializeMintCloseAuthorityInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            closeAuthority: closeAuthorityOption ? closeAuthority : null,\n        },\n    };\n}\n","import { seq, struct, u16, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport type { ExtensionType } from '../extensions/extensionType.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface ReallocateInstructionData {\n    instruction: TokenInstruction.Reallocate;\n    extensionTypes: ExtensionType[];\n}\n\n/**\n * Construct a Reallocate instruction\n *\n * @param account        Address of the token account\n * @param payer          Address paying for the reallocation\n * @param extensionTypes Extensions to reallocate for\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createReallocateInstruction(\n    account: PublicKey,\n    payer: PublicKey,\n    extensionTypes: ExtensionType[],\n    owner: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const baseKeys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ];\n    const keys = addSigners(baseKeys, owner, multiSigners);\n\n    const reallocateInstructionData = struct<ReallocateInstructionData>([\n        u8('instruction'),\n        seq(u16(), extensionTypes.length, 'extensionTypes'),\n    ]);\n    const data = Buffer.alloc(reallocateInstructionData.span);\n    reallocateInstructionData.encode({ instruction: TokenInstruction.Reallocate, extensionTypes }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** Deserialized instruction for the initiation of an immutable owner account */\nexport interface InitializeNonTransferableMintInstructionData {\n    instruction: TokenInstruction.InitializeNonTransferableMint;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeNonTransferableMintInstructionData = struct<InitializeNonTransferableMintInstructionData>([\n    u8('instruction'),\n]);\n\n/**\n * Construct an InitializeNonTransferableMint instruction\n *\n * @param mint           Mint Account to make non-transferable\n * @param programId         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeNonTransferableMintInstruction(\n    mint: PublicKey,\n    programId: PublicKey\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeNonTransferableMintInstructionData.span);\n    initializeNonTransferableMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeNonTransferableMint,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface InitializePermanentDelegateInstructionData {\n    instruction: TokenInstruction.InitializePermanentDelegate;\n    delegate: PublicKey;\n}\n\n/** TODO: docs */\nexport const initializePermanentDelegateInstructionData = struct<InitializePermanentDelegateInstructionData>([\n    u8('instruction'),\n    publicKey('delegate'),\n]);\n\n/**\n * Construct an InitializePermanentDelegate instruction\n *\n * @param mint               Token mint account\n * @param permanentDelegate  Authority that may sign for `Transfer`s and `Burn`s on any account\n * @param programId          SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializePermanentDelegateInstruction(\n    mint: PublicKey,\n    permanentDelegate: PublicKey | null,\n    programId: PublicKey\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializePermanentDelegateInstructionData.span);\n    initializePermanentDelegateInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializePermanentDelegate,\n            delegate: permanentDelegate || new PublicKey(0),\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializePermanentDelegate instruction */\nexport interface DecodedInitializePermanentDelegateInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializePermanentDelegate;\n        delegate: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializePermanentDelegate instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializePermanentDelegateInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedInitializePermanentDelegateInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializePermanentDelegateInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializePermanentDelegateInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializePermanentDelegate) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializePermanentDelegate instruction */\nexport interface DecodedInitializePermanentDelegateInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        delegate: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializePermanentDelegate instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializePermanentDelegateInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializePermanentDelegateInstructionUnchecked {\n    const { instruction, delegate } = initializePermanentDelegateInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            delegate,\n        },\n    };\n}\n"],"names":["amountToUiAmountInstructionData","struct","u8","u64","createAmountToUiAmountInstruction","mint","amount","programId","TOKEN_PROGRAM_ID","keys","pubkey","isSigner","isWritable","data","Buffer","alloc","span","encode","instruction","TokenInstruction","BigInt","TransactionInstruction","decodeAmountToUiAmountInstruction","equals","TokenInvalidInstructionProgramError","length","TokenInvalidInstructionDataError","decodeAmountToUiAmountInstructionUnchecked","TokenInvalidInstructionTypeError","TokenInvalidInstructionKeysError","decode","async","amountToUiAmount","connection","payer","transaction","Transaction","add","returnData","err","simulateTransaction","value","from","toString","getSigners","signerOrMultisig","multiSigners","PublicKey","publicKey","approve","account","delegate","owner","confirmOptions","ownerPublicKey","signers","createApproveInstruction","sendAndConfirmTransaction","approveCheckedInstructionData","createApproveCheckedInstruction","decimals","addSigners","decodeApproveCheckedInstruction","decodeApproveCheckedInstructionUnchecked","approveChecked","burnInstructionData","createBurnInstruction","decodeBurnInstruction","decodeBurnInstructionUnchecked","burn","burnCheckedInstructionData","createBurnCheckedInstruction","decodeBurnCheckedInstruction","decodeBurnCheckedInstructionUnchecked","burnChecked","closeAccountInstructionData","createCloseAccountInstruction","destination","authority","decodeCloseAccountInstruction","decodeCloseAccountInstructionUnchecked","closeAccount","authorityPublicKey","createAssociatedTokenAccount","associatedTokenProgramId","ASSOCIATED_TOKEN_PROGRAM_ID","associatedToken","getAssociatedTokenAddress","createAssociatedTokenAccountInstruction","createAccount","keypair","mintState","getMint","commitment","space","getAccountLenForMint","lamports","getMinimumBalanceForRentExemption","SystemProgram","fromPubkey","newAccountPubkey","createInitializeAccountInstruction","createAssociatedTokenAccountIdempotent","createAssociatedTokenAccountIdempotentInstruction","initializeMint2InstructionData","createInitializeMint2Instruction","mintAuthority","freezeAuthority","freezeAuthorityOption","decodeInitializeMint2Instruction","decodeInitializeMint2InstructionUnchecked","createMint","Keypair","getMinimumBalanceForRentExemptMint","MINT_SIZE","initializeMultisigInstructionData","createInitializeMultisigInstruction","m","SYSVAR_RENT_PUBKEY","signer","push","decodeInitializeMultisigInstruction","rent","decodeInitializeMultisigInstructionUnchecked","createMultisig","getMinimumBalanceForRentExemptMultisig","MULTISIG_SIZE","createNativeMintInstructionData","createCreateNativeMintInstruction","nativeMintId","NATIVE_MINT_2022","TOKEN_2022_PROGRAM_ID","programSupportsExtensions","TokenUnsupportedInstructionError","createNativeMint","nativeMint","createWrappedNativeAccount","NATIVE_MINT","toPubkey","createSyncNativeInstruction","getMinimumBalanceForRentExemptAccount","ACCOUNT_SIZE","freezeAccount","createFreezeAccountInstruction","getOrCreateAssociatedTokenAccount","allowOwnerOffCurve","getAccount","error","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidMintError","TokenInvalidOwnerError","mintTo","createMintToInstruction","mintToCheckedInstructionData","createMintToCheckedInstruction","decodeMintToCheckedInstruction","decodeMintToCheckedInstructionUnchecked","mintToChecked","revoke","createRevokeInstruction","AuthorityType","setAuthorityInstructionData","createSetAuthorityInstruction","currentAuthority","authorityType","newAuthority","newAuthorityOption","decodeSetAuthorityInstruction","decodeSetAuthorityInstructionUnchecked","setAuthority","currentAuthorityPublicKey","syncNative","thawAccount","createThawAccountInstruction","transfer","source","createTransferInstruction","transferCheckedInstructionData","createTransferCheckedInstruction","decodeTransferCheckedInstruction","decodeTransferCheckedInstructionUnchecked","transferChecked","createUiAmountToAmountInstruction","buf","uiAmountToAmountInstructionData","blob","decodeUiAmountToAmountInstruction","decodeUiAmountToAmountInstructionUnchecked","uiAmountToAmount","CpiGuardInstruction","cpiGuardInstructionData","createEnableCpiGuardInstruction","createCpiGuardInstruction","Enable","createDisableCpiGuardInstruction","Disable","cpiGuardInstruction","enableCpiGuard","disableCpiGuard","DefaultAccountStateInstruction","defaultAccountStateInstructionData","createInitializeDefaultAccountStateInstruction","accountState","defaultAccountStateInstruction","Initialize","createUpdateDefaultAccountStateInstruction","Update","initializeDefaultAccountState","state","updateDefaultAccountState","freezeAuthorityPublicKey","InterestBearingMintInstruction","interestBearingMintInitializeInstructionData","s16","interestBearingMintUpdateRateInstructionData","createInitializeInterestBearingMintInstruction","rateAuthority","rate","interestBearingMintInstruction","createUpdateRateInterestBearingMintInstruction","UpdateRate","createInterestBearingMint","mintLen","getMintLen","ExtensionType","createInitializeMintInstruction","updateRateInterestBearingMint","rateAuthorityPublicKey","MemoTransferInstruction","memoTransferInstructionData","createEnableRequiredMemoTransfersInstruction","createMemoTransferInstruction","createDisableRequiredMemoTransfersInstruction","memoTransferInstruction","enableRequiredMemoTransfers","disableRequiredMemoTransfers","TransferFeeInstruction","initializeTransferFeeConfigInstructionData","u16","createInitializeTransferFeeConfigInstruction","transferFeeConfigAuthority","withdrawWithheldAuthority","transferFeeBasisPoints","maximumFee","transferFeeInstruction","InitializeTransferFeeConfig","transferFeeConfigAuthorityOption","withdrawWithheldAuthorityOption","decodeInitializeTransferFeeConfigInstruction","decodeInitializeTransferFeeConfigInstructionUnchecked","transferCheckedWithFeeInstructionData","createTransferCheckedWithFeeInstruction","fee","TransferCheckedWithFee","decodeTransferCheckedWithFeeInstruction","decodeTransferCheckedWithFeeInstructionUnchecked","withdrawWithheldTokensFromMintInstructionData","createWithdrawWithheldTokensFromMintInstruction","WithdrawWithheldTokensFromMint","decodeWithdrawWithheldTokensFromMintInstruction","decodeWithdrawWithheldTokensFromMintInstructionUnchecked","withdrawWithheldTokensFromAccountsInstructionData","createWithdrawWithheldTokensFromAccountsInstruction","sources","WithdrawWithheldTokensFromAccounts","numTokenAccounts","decodeWithdrawWithheldTokensFromAccountsInstruction","decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked","slice","harvestWithheldTokensToMintInstructionData","createHarvestWithheldTokensToMintInstruction","HarvestWithheldTokensToMint","decodeHarvestWithheldTokensToMintInstruction","decodeHarvestWithheldTokensToMintInstructionUnchecked","transferCheckedWithFee","withdrawWithheldTokensFromMint","withdrawWithheldTokensFromAccounts","harvestWithheldTokensToMint","initializeAccount2InstructionData","createInitializeAccount2Instruction","decodeInitializeAccount2Instruction","decodeInitializeAccount2InstructionUnchecked","initializeAccount3InstructionData","createInitializeAccount3Instruction","decodeInitializeAccount3Instruction","decodeInitializeAccount3InstructionUnchecked","decodeInstruction","type","decodeInitializeMintInstruction","decodeInitializeAccountInstruction","decodeTransferInstruction","decodeApproveInstruction","decodeRevokeInstruction","decodeMintToInstruction","decodeFreezeAccountInstruction","decodeThawAccountInstruction","decodeSyncNativeInstruction","isInitializeMintInstruction","decoded","isInitializeAccountInstruction","isInitializeMultisigInstruction","isTransferInstruction","isApproveInstruction","isRevokeInstruction","isSetAuthorityInstruction","isMintToInstruction","isBurnInstruction","isCloseAccountInstruction","isFreezeAccountInstruction","isThawAccountInstruction","isTransferCheckedInstruction","isApproveCheckedInstruction","isMintToCheckedInstruction","isBurnCheckedInstruction","isInitializeAccount2Instruction","isSyncNativeInstruction","isInitializeAccount3Instruction","isInitializeMint2Instruction","isAmountToUiAmountInstruction","isUiamountToAmountInstruction","initializeImmutableOwnerInstructionData","createInitializeImmutableOwnerInstruction","decodeInitializeImmutableOwnerInstruction","decodeInitializeImmutableOwnerInstructionUnchecked","initializeMintCloseAuthorityInstructionData","createInitializeMintCloseAuthorityInstruction","closeAuthority","closeAuthorityOption","decodeInitializeMintCloseAuthorityInstruction","decodeInitializeMintCloseAuthorityInstructionUnchecked","createReallocateInstruction","extensionTypes","baseKeys","reallocateInstructionData","seq","initializeNonTransferableMintInstructionData","createInitializeNonTransferableMintInstruction","initializePermanentDelegateInstructionData","createInitializePermanentDelegateInstruction","permanentDelegate","decodeInitializePermanentDelegateInstruction","decodeInitializePermanentDelegateInstructionUnchecked"],"sourceRoot":""}